<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一致性hash环及优化方法]]></title>
    <url>%2F2020%2F03%2F17%2F%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%8E%AF%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一致性哈希算法在1997年由麻省理工学院的Karger等人在解决分布式Cache中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得DHT可以在P2P环境中真正得到应用。 一致性hash的原理现在一致性hash算法在分布式系统中也得到了广泛应用，研究过memcached缓存数据库的人都知道，memcached服务器端本身不提供分布式cache的一致性，而是由客户端来提供，具体在计算一致性hash时采用如下步骤： 首先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上。 从上图的状态中添加一台memcached服务器。余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但Consistent Hashing中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响，如下图所示： 值得注意的是，一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。 优化方法通过增加虚拟节点来解决数据倾斜问题一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点： 当我们添加的虚拟节点越多，虚拟节点分布就越平均，数据倾斜的程度就越小。我们一般建议虚拟节点大概在200个左右。但是问题来了，如果大量的虚拟节点，节点的查找性能就成为必须考虑的因数。 使用红黑树来加快查找速度红黑树已经广泛应用，其原理就不再叙述了。 实现一致性哈希go语言版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358package hashring// 提供一个一致性哈希环功能// 加入了两个优化点// 1. 增加虚拟节点，用于删除节点后，可以把负载相对均匀地分布分布给其他节点// 2. 增加红黑树结构，优化查询节点的效率//// @author jintangimport ( "fmt" "strconv" "strings" "sync" "hash/crc32" "io" "github.com/HuKeping/rbtree")// Node 节点结构type Node struct &#123; ID string Host string Data *sync.Map&#125;// nodeKey 生成node keyfunc (n *Node) nodeKey() string &#123; return n.ID + "#" + n.Host&#125;// Less 实现rbtree接口方法Less// 实现改接口，可以使Node可以存入rbtree节点func (n *Node) Less(than rbtree.Item) bool &#123; return CalcCRC32([]byte(n.ID)) &lt; CalcCRC32([]byte(than.(*Node).ID))&#125;// VNode 虚拟节点type VNode struct &#123; Index uint32 // 索引值, 通过计算hashKey转crc32得来 NodeID string // Node节点ID&#125;// Less 实现rbtree接口方法Less// 实现改接口，可以使Node可以存入rbtree节点func (vn *VNode) Less(than rbtree.Item) bool &#123; return vn.Index &lt; than.(*VNode).Index&#125;// HashRing 哈希环type HashRing struct &#123; VRing *rbtree.Rbtree NRing *rbtree.Rbtree Nodes *sync.Map // map(NodeID =&gt; *Node) NodeStatus map[string]bool // map(NodeID =&gt; status) NodeCount uint32 NodeOkCount uint32 NumberOfVirtual uint32 sync.Mutex&#125;// virtualKey 生成虚拟节点的keyfunc (r *HashRing) virtualKey(nodeID string, index uint32) string &#123; return "node#" + nodeID + "#" + strconv.FormatUint(uint64(index), 10)&#125;// hashKey 获取哈希func (r *HashRing) hashKey(key string) string &#123; return CalcHash([]byte(key))&#125;// hashTOCRC32 hash转换RCR32func (r *HashRing) hashToCRC32(hashInString string) uint32 &#123; return CalcCRC32([]byte(hashInString))&#125;// CalcIndex 计算key的索引值func (r *HashRing) CalcIndex(key string) uint32 &#123; return r.hashToCRC32(r.hashKey(key))&#125;// AddNode 添加节点func (r *HashRing) AddNode(node *Node) &#123; r.Lock() defer r.Unlock() var numberOfNode uint32 = 1 if r.NumberOfVirtual &gt; 0 &#123; numberOfNode = r.NumberOfVirtual &#125; var i uint32 for i = 0; i &lt; numberOfNode; i++ &#123; index := r.hashToCRC32(r.hashKey(r.virtualKey(node.ID, i))) r.VRing.Insert(&amp;VNode&#123;Index: index, NodeID: node.ID&#125;) &#125; r.Nodes.Store(node.ID, node) r.NodeStatus[node.ID] = false r.NRing.Insert(node) r.NodeCount++&#125;// RemoveNode 删除节点func (r *HashRing) RemoveNode(nodeID string) bool &#123; r.Lock() defer r.Unlock() if val, ok := r.Nodes.Load(nodeID); ok &#123; node := val.(*Node) var numberOfNode uint32 = 1 if r.NumberOfVirtual &gt; 0 &#123; numberOfNode = r.NumberOfVirtual &#125; var i uint32 for i = 0; i &lt; numberOfNode; i++ &#123; index := r.hashToCRC32(r.hashKey(r.virtualKey(node.ID, i))) r.VRing.Delete(&amp;VNode&#123;Index: index, NodeID: node.ID&#125;) &#125; r.Nodes.Delete(node.ID) delete(r.NodeStatus, node.ID) r.NRing.Delete(node) r.NodeCount-- &#125; return true&#125;func (r *HashRing) Node(ID string) *Node &#123; if node, ok := r.Nodes.Load(ID); ok &#123; return node.(*Node) &#125; return nil&#125;func (r *HashRing) IsOnline(ID string) bool &#123; ok, online := r.NodeStatus[ID] return ok &amp;&amp; online&#125;func (r *HashRing) SetOffline(ID string) &#123; r.Lock() defer r.Unlock() if b, ok := r.NodeStatus[ID]; ok &amp;&amp; b &#123; r.NodeStatus[ID] = false r.NodeOkCount-- &#125;&#125;func (r *HashRing) SetOnline(ID string) &#123; r.Lock() defer r.Unlock() if b, ok := r.NodeStatus[ID]; ok &amp;&amp; !b &#123; r.NodeOkCount++ r.NodeStatus[ID] = true &#125;&#125;func (r *HashRing) RandomGetNodes(num int) []*Node &#123; if r.NodeOkCount &lt;= 0 &#123; return nil &#125; if r.NodeOkCount &lt; uint32(num) &#123; num = int(r.NodeOkCount) &#125; nodes := make([]*Node, num) ids := make([]string, 0) for id, ok := range r.NodeStatus &#123; if ok &#123; ids = append(ids, id) &#125; &#125; indexes := utils.GenerateRandomNumber(0, len(ids), num) for i, idx := range indexes &#123; if node, ok := r.Nodes.Load(ids[idx]); ok &#123; nodes[i] = node.(*Node) &#125; &#125; return nodes&#125;// GetNode 定位节点// @params key 直接通过key值获取func (r *HashRing) GetNode(key string) (uint32, string) &#123; keyIndex := r.hashToCRC32(r.hashKey(key)) return r.GetNodeByIndex(keyIndex)&#125;// GetNodeMissNodeID 获取节点，排除不要的的节点// @params key 直接通过key获取，NodeID需要排除的节点IDfunc (r *HashRing) GetNodeMissNodeIDs(key string, NodeIDs []string) (uint32, string) &#123; if len(NodeIDs) &lt;= 0 &#123; return r.GetNode(key) &#125; if uint32(len(NodeIDs)) &gt;= r.NodeCount || r.NodeCount &lt;= 0 &#123; return 0, "" &#125; for _, id := range NodeIDs &#123; r.SetOffline(id) &#125; index, id := r.GetNode(key) for _, id := range NodeIDs &#123; r.SetOffline(id) &#125; return index, id&#125;// GetNodeUpDownNodes 获取节点上下游节点// @params NodeID节点IDfunc (r *HashRing) GetNodeUpDownNodes(NodeID string) (string, string) &#123; if NodeID == "" || !r.NodeStatus[NodeID] || r.NodeCount &lt;= 0 &#123; return "", "" &#125; if r.NRing.Len() &gt; 1 &#123; up := r.NRing.Max().(*Node).ID down := r.NRing.Min().(*Node).ID r.NRing.Descend(&amp;Node&#123;ID: NodeID&#125;, func(item rbtree.Item) bool &#123; if CalcCRC32([]byte(NodeID)) == CalcCRC32([]byte(item.(*Node).ID)) &#123; return true &#125; up = item.(*Node).ID return false &#125;) r.NRing.Ascend(&amp;Node&#123;ID: NodeID&#125;, func(item rbtree.Item) bool &#123; if CalcCRC32([]byte(NodeID)) == CalcCRC32([]byte(item.(*Node).ID)) &#123; return true &#125; down = item.(*Node).ID return false &#125;) return up, down &#125; return "", ""&#125;// GetNodeByIndex 定位节点// @params keyIndex 通过索引值获取func (r *HashRing) GetNodeByIndex(keyIndex uint32) (uint32, string) &#123; if r.VRing.Len() &gt; 0 &#123; minVNodeOfRing := r.VRing.Min().(*VNode) vNode := minVNodeOfRing r.VRing.Ascend(&amp;VNode&#123;Index: keyIndex&#125;, func(item rbtree.Item) bool &#123; vNode = item.(*VNode) if r.NodeStatus[vNode.NodeID] == false &#123; return true &#125; return false &#125;) if !r.NodeStatus[vNode.NodeID] &#123; r.VRing.Ascend(minVNodeOfRing, func(item rbtree.Item) bool &#123; vNode = item.(*VNode) if r.NodeStatus[vNode.NodeID] == false &#123; return true &#125; return false &#125;) &#125; return vNode.Index, vNode.NodeID &#125; return 0, ""&#125;// PrintNodes 打印所有真实节点func (r *HashRing) PrintNodes() &#123; if r.NodeCount &lt;= 0 &#123; fmt.Println("nodes is empty") return &#125; r.Nodes.Range(func(key, value interface&#123;&#125;) bool &#123; node := value.(*Node) fmt.Println(strings.Repeat("=", 30)) fmt.Println("NodeID:", node.ID) fmt.Println("NodeHost:", node.Host) fmt.Println("NodeKey :", node.nodeKey()) fmt.Println() return true &#125;)&#125;// TraversalVRing 遍历虚拟节点二叉树func (r *HashRing) TraversalVRing() &#123; r.VRing.Ascend(r.VRing.Min(), func(item rbtree.Item) bool &#123; fmt.Printf("vNode %d =&gt; %s\n", item.(*VNode).Index, item.(*VNode).NodeID) return true &#125;)&#125;// TraversalNRing 遍历真实节点二叉树func (r *HashRing) TraversalNRing() &#123; r.NRing.Ascend(r.NRing.Min(), func(item rbtree.Item) bool &#123; fmt.Printf("Node %d =&gt; %s\n", CalcCRC32([]byte(item.(*Node).ID)), item.(*Node).ID) return true &#125;)&#125;// NewHashRing 新建一个hash环func New(numOfVNode uint32) *HashRing &#123; r := new(HashRing) r.Nodes = new(sync.Map) r.NodeStatus = make(map[string]bool) r.NodeCount = 0 r.NumberOfVirtual = numOfVNode r.VRing = rbtree.New() r.NRing = rbtree.New() return r&#125;// CalcCRC32 计算crc32func CalcCRC32(data []byte) uint32 &#123; iEEE := crc32.NewIEEE() io.WriteString(iEEE, string(data)) return iEEE.Sum32()&#125;]]></content>
      <tags>
        <tag>golang</tag>
        <tag>hash</tag>
        <tag>一致性hash</tag>
        <tag>p2p</tag>
        <tag>分布式系统</tag>
        <tag>虚拟节点</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka基本原理]]></title>
    <url>%2F2019%2F12%2F30%2Fkafka%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Kafka 是一个基于分布式的消息发布-订阅系统，它被设计成快速、可扩展的、持久的。与其他消息发布-订阅系统类似，Kafka 在主题当中保存消息的信息。生产者向主题写入数据，消费者从主题读取数据。由于 Kafka 的特性是支持分布式，同时也是基于分布式的，所以主题也是可以在多个节点上被分区和覆盖的。 专业术语Broker：Kafka 集群包含一个或多个服务器，这种服务器被称为 broker。 Topic：每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。 Partition：Partition 是物理上的概念，每个 Topic 包含一个或多个 Partition。 Producer：负责发布消息到 Kafka broker。 Consumer：消息消费者，向 Kafka broker 读取消息的客户端。 Consumer Group：每个 Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。 ##]]></content>
      <tags>
        <tag>kafka</tag>
        <tag>apache</tag>
        <tag>消息系统</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制——Git的使用]]></title>
    <url>%2F2019%2F11%2F05%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94Git%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <tags>
        <tag>版本控制</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非对称加密的原理及应用]]></title>
    <url>%2F2019%2F10%2F29%2F%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引用来自wiki对于非对称加密的通俗介绍：在现实世界上可作比拟的例子是，一个传统保管箱，开门和关门都是使用同一条钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有信箱主人拥有钥匙可以打开信箱，这就视为私钥，这是非对称加密。RSA是使用最为广泛的非对称加密算法，而http到https的演进就依赖于RSA非对称加密算法。 HTTP到HTTPS的演进HTTPHTTP协议是基于传输层TCP协议的应用层协议，时至今日，它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP是一个client-server协议：请求通过一个实体被发出，实体也就是用户代理。大多数情况下，这个用户代理都是指浏览器，当然它也可能是任何东西，比如一个爬取网页生成维护搜索引擎索引的机器爬虫。每一个发送到服务器的请求，都会被服务器处理并返回一个消息，也就是response。HTTP是简单的、可扩展的、无状态的、有会话的、面向连接的传输协议。但是HTTP也存在以下问题： 通讯使用明文，可能被窃听。 无法证明报文的完整性，可能被篡改。 无法验证通讯方的身份，可能被欺骗。 HTTPSHTTPS使用TLS/SSL作为传输层安全协议，拥有认证、保密和数据完整性功能。HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 TLS/SSL = 非对称加密(RSA) + 对称加密(AES) + 散列算法(SHA)。 解决内容可能被窃听的问题——非对称加密+对称加密。 解决报文可能遭篡改问题——数字签名。 解决通信方身份可能被伪装的问题——数字证书。 1.Client发起一个HTTPS（比如https://juejin.im/user/5a9a9cdcf265da238b7d771c）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。 2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。 3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。 4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。6.Server使用对称密钥加密“明文内容A”，发送给Client。 7.Client使用对称密钥解密响应的密文，得到“明文内容A”。 8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。 RSA加密算法为什么要使用公钥加密私钥解密？ 密码学的假设是：一个合格的加密方案，敌手拿到明文c不能恢复明文m。如果颠倒过来，所有人都可以解密，那毫无意义。 为了满足密码标准，非对称加密的加密密钥尽可能更安全高效，而私钥尽可能保证安全，防止被破解，这就导致人们设计时公钥加解密比私钥加解密快。所以要用公钥进行加密，私钥进行解密。test1]]></content>
      <tags>
        <tag>密钥</tag>
        <tag>非对称加密</tag>
        <tag>对称加密</tag>
        <tag>http</tag>
        <tag>https</tag>
        <tag>RSA</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[食物寒凉温热属性速查]]></title>
    <url>%2F2019%2F09%2F17%2F%E9%A3%9F%E7%89%A9%E5%AF%92%E5%87%89%E6%B8%A9%E7%83%AD%E5%B1%9E%E6%80%A7%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[中医认为“寒凉为阴，温热为阳”，只有将食物的寒凉温热因人、因时、因地的灵活运用，才能使人体在任何时候都能做到阴阳平衡。其一，根据个人体质选择食物，身体内寒气较重、气血两亏的虚弱之人不分季节，要多吃温热性质的食物，使机能兴奋、增加活力，血脉畅通；如果身体内热量较大、精力旺盛，要适当地选用一些寒凉的食物来进行平衡。其二，气候的变化说到底就是温度的变化，温度高时人要多吃寒凉的食物清热，温度低时要以温热的食物保暖祛寒。其三，每个地区因气候、地理的不同都生长着不同的食物，最明显的就是炎热之地多盛产寒冷性质的水果，而寒冷地区多生长温热的食物，这是大自然给我们准备好的食物，是完全适合身体的东西，正所谓“一方水土养一方人”。 食物分类食物的四性是指寒、凉、温、热四种属性，寒热属性不明显的食物归于平性，但习惯仍称为四性。 寒 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 大白菜 胶菜、绍菜 寒 10月-3月 牛肉、豆腐 兔肉、动物肝脏 2 茄子 茄瓜、矮瓜 寒 6月-7月 猪肉、羊肉 蟹、墨鱼 3 蟹 寒 茄子、西红柿 4 墨鱼 寒 茄子 5 苦瓜 癞瓜、凉瓜 寒 3月-8月 鸡蛋、鹌鹑蛋 动物肝脏、豆腐 6 西葫芦 茭瓜、角瓜 寒 3月-8月 豆腐、鸡蛋、韭菜 7 莴笋 莴苣、青笋、生笋 寒 12月-2月 蒜薹、沙拉酱 蜂蜜、乳酪 8 竹笋 竹萌、竹芽 寒 3月-11月 鸡肉、猪肉、酸菜 红糖、山楂 9 芦笋 文山竹、笋尖马 寒 4月-5月 冬瓜、海参、猪肉、黄芪 10 莲藕 藕、河梗、灵根 寒 12月-5月 凉 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 兔肉 凉 大白菜 2 油菜 芸薹、胡菜、寒菜 凉 10月-12月 香菇、虾仁 胡萝卜、动物肝脏 3 白萝卜 菜菔、罗服 凉 11月-2月 鸡肉、羊肉 梨、柑橘 4 西红柿 番茄、洋茄子 凉 7月-9月 菜花、鸡蛋、圆白菜、芹菜 虾、蟹、黄瓜 5 冬瓜 白瓜、白冬瓜、枕瓜 凉 12月-5月 香菇、海带、芦笋 鲫鱼、红豆 6 黄瓜 胡瓜、刺瓜、王瓜 凉 5月-6月 豆腐、虾 西红柿、花生、菠菜 7 丝瓜 天罗、绵瓜、布瓜、天罗瓜 凉 6月-8月 8 菠菜 菠棱、赤根菜 凉 3月-11月 鸡蛋、猪血 豆腐、黄瓜 9 芹菜 胡芹、旱芹、水芹 凉 11月-3月 西红柿、牛肉 鸡肉 平 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 西兰花 绿花椰菜、绿花菜 平 5月 平菇、金针菇、豆浆、百合 2 菜花 花菜、花椰菜 平 5月 猪肉、鸡肉、鸡蛋 动物肝脏、胡萝卜 3 豇豆 饭豆、长豆角 平 6月-9月 猪肉 4 胡萝卜 黄萝卜、红萝卜 平 9月-2月 羊肉、猪肝 山楂、醋 5 圆白菜 包心菜、卷心菜 平 3月-8月 黑木耳、西红柿 动物肝脏 6 土豆 马铃薯、洋芋 平 12月-5月 牛肉、豆角 柿子、香蕉 7 茼蒿 蓬蒿、蒿子轩、皇帝菜 平 12月-5月 温 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 鲫鱼 温 冬瓜 2 南瓜 矮瓜、番瓜、麦瓜 温 7月-9月 芦荟、莲子 红薯、带鱼 3 青椒 柿子椒、甜椒 温 3月-8月 4 尖椒 温 3月-8月 5 洋葱 葱头、徐聪、圆葱 温 9月-2月 6 川七 温 7 山药 温 8 包心芹菜 温 9 明日叶 温 10 韭菜 温 11 韭菜花 温 12 紫苏 温 13 雪里红 雪菜、春不老、香青菜 温 14 袖珍菇 温 15 鲍鱼菇 温 16 黑豆芽 温 17 桃子 温 18 杨梅 温 19 水蜜桃 温 20 红枣 温 21 荔枝 温 22 龙眼 桂圆 温 23 樱桃 温 24 石榴 温 25 红毛丹 温 26 鸭梨 温 27 金桔 温 28 扁豆 藤豆、鹊豆、豆角 温 29 松子 温 30 栗子 温 31 核桃 温 32 雪莲子 温 33 高粱 温 34 西谷米 温 35 糯米 温 36 牛肉 温 37 羊肉 温 38 鸡肉 温 39 火腿 温 40 羊肚 温 41 羊肾 温 42 鸡心 温 43 猪肚 温 44 猪肝 温 45 鹅肝 温 46 羊奶 温 47 鸡蛋黄 温 48 白带鱼 温 49 草鱼 温 50 鳝鱼 温 51 鲫鱼 温 52 鲢鱼 温 53 海参 温 54 虾子 温 55 虾米 温 56 龙虾 温 57 沙拉油 温 58 红砂糖 温 59 麦芽糖 温 60 黑糖 温 61 醋 温 62 蒜 温 63 红花 温 64 香椿 温 65 丁香 温 66 月桂叶 温 67 左手香 温 68 百香里 温 69 茴香菜 温 70 玫瑰 温 71 茉莉 温 72 桂花 温 73 红茶 温 74 咖啡 温 75 米酒 温 热 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 榴莲 热 2 山葵 热 3 白胡椒 热 4 黑胡椒 热 5 朝天椒 热 6 肉桂 热 7 八角 热 8 葡萄酒 热 9 辣椒 热 参考资料食物寒凉温热属性功效速查手册 食物寒熱溫涼屬性表 备注内容持续更新中，敬请期待……]]></content>
      <tags>
        <tag>食物</tag>
        <tag>寒凉温热</tag>
        <tag>四性</tag>
        <tag>食用时令</tag>
        <tag>食物搭配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang深入学习——float]]></title>
    <url>%2F2019%2F09%2F07%2FGolang%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94float%2F</url>
    <content type="text"><![CDATA[在计算机科学中，浮点数是一种对于实数的近似值数值表现法，利用浮点进行运算，称为浮点计算，这种运算通常伴随着因为无法精确表示而进行的近似或舍入。Go提供了两种size的浮点数，float32和float64。它们的算术规范是由IEEE754国际标准定义，现代CPU都实现了这个规范。 内存中的float32定义float32——单精度浮点类型使用32位（4个字节）存储一个浮点数。 IEEE754-2008中定义了它的结构： 符号位 指数 尾数 S EEEEEEEE FFFFFFFFFFFFFFFFFFFFFFF 1位二进制表示符号: 0,正; 1,负 8位二进制表示127偏移量的指数 23位二进制表示23+1位小数部分 例子以6.9为例子，将生活中常见的十进制转化为机器存储的二进制float。 将整数和小数部分分别转化为二进制； 1236（十进制） = 110（二进制）0.9（十进制） = 1110011001100......（二进制）6.9（十进制） = 110.1110011001100......（二进制） 将小数点左移（或右移）到第一个有效数字之后； 1110.1110011001100...... =&gt; 1.101110011001100......（左移2位） 填充尾数部分； 1从小数点后第一位开始，数出23个来，填充到上面float内存结构的尾数部分。默认小数点前面一定有且只有一个1，所以把这个1省略了，这也是为什么定义中尾数是23+1位的原因。 填充指数部分； 1238位表示阶码，无符号是[1,254]，0和255用于表示非规格化情况，有符号位是[-126,127]，引入偏移量以免使用补码带来计算复杂度。这个指数就是刚才我们把小数点移动的位数，左移为正，右移为负，用来计算指数的偏移量为127，指数应该是2+127=129。129（十进制） = 10000001（十进制） 填充符号位。 符号位 指数 尾数 0 10000001 10111001100110011001100 不精确的原因 浮点型只有最后一位为5时才能用有限位数的二进制来表示； 单精度浮点型尾数部分只能保存23位。 内存中的float64float64——双精度浮点类型使用64位（8个字节）存储一个浮点数。 IEEE754-2008中定义了它的结构： 符号位 指数 尾数 S EEEEEEEEEEE FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 1位二进制表示符号: 0,正; 1,负 11位二进制表示1023偏移量的指数 52位二进制表示52+1位小数部分]]></content>
      <tags>
        <tag>golang</tag>
        <tag>数据结构</tag>
        <tag>float</tag>
        <tag>浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang深入学习——map]]></title>
    <url>%2F2019%2F09%2F05%2FGolang%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94map%2F</url>
    <content type="text"><![CDATA[在Go语言中，一个map就是一个哈希表的引用，哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。对于V对应的value数据类型则没有任何的限制。 基本操作创建内置的make函数： 1ages := make(map[string]int) map字面值的语法： 1234ages := map[string]int&#123; "alice": 31, "charlie": 34,&#125; 访问通过key对应的下标语法访问： 12ages["alice"] = 32fmt.Println(ages["alice"]) 即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值。 元素是否真的是在map之中： 1234age, ok := ages["bob"]if !ok &#123; //do something&#125; 删除使用内置的delete函数可以删除元素： 1delete(ages, "alice") 遍历想遍历map中全部的key/value对的话，可以使用range风格的for循环实现： 123for name, age := range ages &#123; fmt.Printf("%s\t%d\n", name, age)&#125; Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。 数据结构存储查询Golang采用的是哈希查找表，并且使用链表解决哈希冲突。 1234567891011121314151617181920// A header for a Go map.type hmap struct &#123; // 元素个数，调用 len(map) 时，直接返回此值 count int flags uint8 // buckets 的对数 log_2 B uint8 // overflow 的 bucket 近似数 noverflow uint16 // 计算 key 的哈希的时候会传入哈希函数 hash0 uint32 // 指向 buckets 数组，大小为 2^B // 如果元素个数为0，就为 nil buckets unsafe.Pointer // 扩容的时候，buckets 长度会是 oldbuckets 的两倍 oldbuckets unsafe.Pointer // 指示扩容进度，小于此地址的 buckets 迁移完成 nevacuate uintptr extra *mapextra // optional fields&#125; 说明一下，B 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。bucket 里面存储了 key 和 value。buckets 是一个指针，最终它指向的是一个结构体： 123type bmap struct &#123; tophash [bucketCnt]uint8&#125; bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。 每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 overflow 指针连接起来。 key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。 buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。 循环遍历map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key/value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。 当然，Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了。 多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。 再明确一个问题：如果扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶。 map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。 一般而言，这可以通过读写锁来解决：sync.RWMutex。 读之前调用 RLock() 函数，读完之后调用 RUnlock() 函数解锁；写之前调用 Lock() 函数，写完之后，调用 Unlock() 解锁。 另外，sync.Map 是线程安全的 map，也可以使用。]]></content>
      <tags>
        <tag>golang</tag>
        <tag>map</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库安全——SQL注入]]></title>
    <url>%2F2017%2F04%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[不管用什么语言编写的Web应用，它们都用一个共同点，具有交互性并且多数是数据库驱动。在网络中，数据库驱动的Web应用随处可见，由此而存在的SQL注入是影响企业运营且最具破坏性的漏洞之一。 SQL注入定义SQL注入（SQL injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。 简单解释：SQL注入就是一种通过操作输入来修改后台SQL语句达到代码执行进行攻击目的的技术。 SQL注入实例多语句执行注入Get请求语句： 1http://localhost/test/userinfo.php?username=plhwin SQL语句： 1SELECT uid,username FROM user WHERE username='plhwin' 如果用户Get请求改为： 1http://localhost/test/userinfo.php?username=plhwin';SHOW TABLES-- hack SQL语句变为： 1SELECT uid,username FROM user WHERE username='plhwin';SHOW TABLES-- hack' 经过上面的SQL注入后，页面输出了所有表信息。 如果用户接着Get请求： 1http://localhost/test/userinfo.php?username=plhwin';DROP TABLE user-- hack 整个user数据库表都消失了。 or方法注入一Web登录表单： 12345&lt;form action="/login" method="POST"&gt; &lt;p&gt;Username: &lt;input type="text" name="username" /&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input type="password" name="password" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="登录" /&gt;&lt;/p&gt;&lt;/form&gt; 后台处理逻辑： 123username:=r.Form.Get("username")password:=r.Form.Get("password")sql:="SELECT * FROM user WHERE username='"+username+"' AND password='"+password+"'" 普通用户输入： 12账户：myuser密码：xxx SQL语句： 1SELECT * FROM user WHERE username='myuser' AND password='xxx' 如果用户输入： 12账户：myuser' or 'foo' = 'foo' --密码：xxx SQL语句变为： 1SELECT * FROM user WHERE username='myuser' or 'foo' = 'foo' --'' AND password='xxx' 在SQL里面–是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。 or方法注入二SQL语句： 1strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');" 如果用户输入： 12userName = "1' OR '1'='1";passWord = "1' OR '1'='1"; SQL语句变为： 1strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');" 上面的SQL语句相当于： strSQL = “SELECT * FROM users;” 控制系统某些版本MSSQL数据库系统命令： 12sql:="SELECT * FROM products WHERE name LIKE '%"+prod+"%'"Db.Exec(sql) 如果攻击者提交一下内容作为变量prod的值： 1a%' exec master..xp_cmdshell 'net user test testpass /ADD' -- SQL语句变为： 1SELECT * FROM products WHERE name LIKE '%a%' exec master..xp_cmdshell 'net user test testpass /ADD'--%' MSSQL服务器会执行这条SQL语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以sa运行而 MSSQLSERVER服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。 可能危害 数据表中的数据外泄，例如个人机密数据，账户数据，密码等。 数据结构被黑客探知，得以做进一步攻击（例如SELECT * FROM sys.tables）。 数据库服务器被攻击，系统管理员账户被窜改（例如ALTER LOGIN sa WITH PASSWORD=’xxxxxx’）。 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及XSS等。 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如xp_cmdshell “net stop iisadmin”可停止服务器的IIS服务）。 破坏硬盘数据，瘫痪全系统（例如xp_cmdshell “FORMAT C:”）。 避免办法SQL注入攻击的危害这么大，那么该如何来防治呢?下面这些建议或许对防治SQL注入有一定的帮助。 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害。 检查输入的数据是否具有所期望的数据格式，严格限制变量的类型，例如使用regexp包进行一些匹配处理，或者使用strconv包对字符串转化成其他基本类型的数据进行判断。 对进入数据库的特殊字符（’”\尖括号&amp;*;等）进行转义处理，或编码转换。Go的text/template包里面的HTMLEscapeString函数可以对字符串进行转义处理。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句。例如使用database/sql里面的查询函数Prepare和Query，或者Exec(query string, args …interface{})。 在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。 避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。]]></content>
      <tags>
        <tag>datebase</tag>
        <tag>safe</tag>
        <tag>sql</tag>
        <tag>injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装NexT主题搭建Github博客]]></title>
    <url>%2F2017%2F03%2F27%2FHexo%E5%AE%89%E8%A3%85NexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BAGithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是高效的静态站点生成框架，她基于 Node.js。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。 搭建博客创建Github仓库在Github页面的右上方选择New repository进行仓库的创建 1my-name.github.io 安装配置Hexo 下载安装Hexo 1npm install -g hexo-cli 初始化Blog 1hexo init blog 下载dependencies 12cd blognpm install 站点配置(blog/_config.yml) 12345678910title: my-titlesubtitle: my-subtitledescription: my-descriptionauthor: my-namelanguage: zh-CNtimezone: Asia/Shanghaideploy: type: git repo: https://github.com/my-name/my-name.github.io.git branch: master 添加标签页面 1hexo new page "tags" 编辑页面(blog/source/tags) 12type: "tags"comments: false 添加评论系统 1234disqus: enable: true shortname: my-shortname count: true 添加NexT主题下载主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题(blog/_config.yml) 1theme: next 选择Scheme(blog/themes/next/_config.yml) 123#scheme: Musescheme: Mist#scheme: Pisces 设置头像(blog/themes/next/_config.yml) avatar放置在blog/themes/next/source/images/目录下 1avatar: /images/avatar.jpg 设置昵称 1author: my-name 站点描述 1description: 总有刁民想害朕 本地测试本地发布 1hexo server 浏览器访问http://localhost:4000/ 远程测试部署到Github 生成网站静态文件到默认public文件 1hexo generate 自动生成静态文件并部署到设定的仓库 1hexo deploy 浏览器访问http://my-name.github.io 如:http://hihcys.github.io 发表文章新建文章 1hexo new "my-first-article" 编辑文章(blog/source/_posts) 1retext my-first-article.md 提交到远程 12hexo generatehexo deploy 相关链接Hexo框架官方文档 Text主题官方文档 Git中文版学习资料]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
