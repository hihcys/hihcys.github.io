<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang深入学习——float]]></title>
    <url>%2F2019%2F09%2F07%2FGolang%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94float%2F</url>
    <content type="text"><![CDATA[在计算机科学中，浮点数是一种对于实数的近似值数值表现法，利用浮点进行运算，称为浮点计算，这种运算通常伴随着因为无法精确表示而进行的近似或舍入。Go提供了两种size的浮点数，float32和float64。它们的算术规范是由IEEE754国际标准定义，现代CPU都实现了这个规范。 内存中的float32定义float32——单精度浮点类型使用32位（4个字节）存储一个浮点数。 IEEE754-2008中定义了它的结构： 符号位 指数 尾数 S EEEEEEEE FFFFFFFFFFFFFFFFFFFFFFF 1位二进制表示符号: 0,正; 1,负 8位二进制表示127偏移量的指数 23位二进制表示23+1位小数部分 例子以6.9为例子，将生活中常见的十进制转化为机器存储的二进制float。 将整数和小数部分分别转化为二进制； 1236（十进制） = 110（二进制）0.9（十进制） = 1110011001100......（二进制）6.9（十进制） = 110.1110011001100......（二进制） 将小数点左移（或右移）到第一个有效数字之后； 1110.1110011001100...... =&gt; 1.101110011001100......（左移2位） 填充尾数部分； 1从小数点后第一位开始，数出23个来，填充到上面float内存结构的尾数部分。默认小数点前面一定有且只有一个1，所以把这个1省略了，这也是为什么定义中尾数是23+1位的原因。 填充指数部分； 1238位表示阶码，无符号是[1,254]，0和255用于表示非规格化情况，有符号位是[-126,127]，引入偏移量以免使用补码带来计算复杂度。这个指数就是刚才我们把小数点移动的位数，左移为正，右移为负，用来计算指数的偏移量为127，指数应该是2+127=129。129（十进制） = 10000001（十进制） 填充符号位。 符号位 指数 尾数 0 10000001 10111001100110011001100 不精确的原因 浮点型只有最后一位为5时才能用有限位数的二进制来表示； 单精度浮点型尾数部分只能保存23位。 内存中的float64float64——双精度浮点类型使用64位（8个字节）存储一个浮点数。 IEEE754-2008中定义了它的结构： 符号位 指数 尾数 S EEEEEEEEEEE FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 1位二进制表示符号: 0,正; 1,负 11位二进制表示1023偏移量的指数 52位二进制表示52+1位小数部分]]></content>
      <tags>
        <tag>golang</tag>
        <tag>数据结构</tag>
        <tag>float</tag>
        <tag>浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang深入学习——map]]></title>
    <url>%2F2019%2F09%2F05%2FGolang%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94map%2F</url>
    <content type="text"><![CDATA[在Go语言中，一个map就是一个哈希表的引用，哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。对于V对应的value数据类型则没有任何的限制。 基本操作创建内置的make函数： 1ages := make(map[string]int) map字面值的语法： 1234ages := map[string]int&#123; "alice": 31, "charlie": 34,&#125; 访问通过key对应的下标语法访问： 12ages["alice"] = 32fmt.Println(ages["alice"]) 即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值。 元素是否真的是在map之中： 1234age, ok := ages["bob"]if !ok &#123; //do something&#125; 删除使用内置的delete函数可以删除元素： 1delete(ages, "alice") 遍历想遍历map中全部的key/value对的话，可以使用range风格的for循环实现： 123for name, age := range ages &#123; fmt.Printf("%s\t%d\n", name, age)&#125; Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。 数据结构存储查询Golang采用的是哈希查找表，并且使用链表解决哈希冲突。 1234567891011121314151617181920// A header for a Go map.type hmap struct &#123; // 元素个数，调用 len(map) 时，直接返回此值 count int flags uint8 // buckets 的对数 log_2 B uint8 // overflow 的 bucket 近似数 noverflow uint16 // 计算 key 的哈希的时候会传入哈希函数 hash0 uint32 // 指向 buckets 数组，大小为 2^B // 如果元素个数为0，就为 nil buckets unsafe.Pointer // 扩容的时候，buckets 长度会是 oldbuckets 的两倍 oldbuckets unsafe.Pointer // 指示扩容进度，小于此地址的 buckets 迁移完成 nevacuate uintptr extra *mapextra // optional fields&#125; 说明一下，B 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。bucket 里面存储了 key 和 value。buckets 是一个指针，最终它指向的是一个结构体： 123type bmap struct &#123; tophash [bucketCnt]uint8&#125; bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。 每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 overflow 指针连接起来。 key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。 buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。 循环遍历map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key/value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。 当然，Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了。 多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。 再明确一个问题：如果扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶。 map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。 一般而言，这可以通过读写锁来解决：sync.RWMutex。 读之前调用 RLock() 函数，读完之后调用 RUnlock() 函数解锁；写之前调用 Lock() 函数，写完之后，调用 Unlock() 解锁。 另外，sync.Map 是线程安全的 map，也可以使用。]]></content>
      <tags>
        <tag>golang</tag>
        <tag>map</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库安全——SQL注入]]></title>
    <url>%2F2017%2F04%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[不管用什么语言编写的Web应用，它们都用一个共同点，具有交互性并且多数是数据库驱动。在网络中，数据库驱动的Web应用随处可见，由此而存在的SQL注入是影响企业运营且最具破坏性的漏洞之一。 SQL注入定义SQL注入（SQL injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。 简单解释：SQL注入就是一种通过操作输入来修改后台SQL语句达到代码执行进行攻击目的的技术。 SQL注入实例多语句执行注入Get请求语句： 1http://localhost/test/userinfo.php?username=plhwin SQL语句： 1SELECT uid,username FROM user WHERE username='plhwin' 如果用户Get请求改为： 1http://localhost/test/userinfo.php?username=plhwin';SHOW TABLES-- hack SQL语句变为： 1SELECT uid,username FROM user WHERE username='plhwin';SHOW TABLES-- hack' 经过上面的SQL注入后，页面输出了所有表信息。 如果用户接着Get请求： 1http://localhost/test/userinfo.php?username=plhwin';DROP TABLE user-- hack 整个user数据库表都消失了。 or方法注入一Web登录表单： 12345&lt;form action="/login" method="POST"&gt; &lt;p&gt;Username: &lt;input type="text" name="username" /&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input type="password" name="password" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="登录" /&gt;&lt;/p&gt;&lt;/form&gt; 后台处理逻辑： 123username:=r.Form.Get("username")password:=r.Form.Get("password")sql:="SELECT * FROM user WHERE username='"+username+"' AND password='"+password+"'" 普通用户输入： 12账户：myuser密码：xxx SQL语句： 1SELECT * FROM user WHERE username='myuser' AND password='xxx' 如果用户输入： 12账户：myuser' or 'foo' = 'foo' --密码：xxx SQL语句变为： 1SELECT * FROM user WHERE username='myuser' or 'foo' = 'foo' --'' AND password='xxx' 在SQL里面–是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。 or方法注入二SQL语句： 1strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');" 如果用户输入： 12userName = "1' OR '1'='1";passWord = "1' OR '1'='1"; SQL语句变为： 1strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');" 上面的SQL语句相当于： strSQL = “SELECT * FROM users;” 控制系统某些版本MSSQL数据库系统命令： 12sql:="SELECT * FROM products WHERE name LIKE '%"+prod+"%'"Db.Exec(sql) 如果攻击者提交一下内容作为变量prod的值： 1a%' exec master..xp_cmdshell 'net user test testpass /ADD' -- SQL语句变为： 1SELECT * FROM products WHERE name LIKE '%a%' exec master..xp_cmdshell 'net user test testpass /ADD'--%' MSSQL服务器会执行这条SQL语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以sa运行而 MSSQLSERVER服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。 可能危害 数据表中的数据外泄，例如个人机密数据，账户数据，密码等。 数据结构被黑客探知，得以做进一步攻击（例如SELECT * FROM sys.tables）。 数据库服务器被攻击，系统管理员账户被窜改（例如ALTER LOGIN sa WITH PASSWORD=’xxxxxx’）。 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及XSS等。 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如xp_cmdshell “net stop iisadmin”可停止服务器的IIS服务）。 破坏硬盘数据，瘫痪全系统（例如xp_cmdshell “FORMAT C:”）。 避免办法SQL注入攻击的危害这么大，那么该如何来防治呢?下面这些建议或许对防治SQL注入有一定的帮助。 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害。 检查输入的数据是否具有所期望的数据格式，严格限制变量的类型，例如使用regexp包进行一些匹配处理，或者使用strconv包对字符串转化成其他基本类型的数据进行判断。 对进入数据库的特殊字符（’”\尖括号&amp;*;等）进行转义处理，或编码转换。Go的text/template包里面的HTMLEscapeString函数可以对字符串进行转义处理。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句。例如使用database/sql里面的查询函数Prepare和Query，或者Exec(query string, args …interface{})。 在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。 避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。]]></content>
      <tags>
        <tag>datebase</tag>
        <tag>safe</tag>
        <tag>sql</tag>
        <tag>injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装NexT主题搭建Github博客]]></title>
    <url>%2F2017%2F03%2F27%2FHexo%E5%AE%89%E8%A3%85NexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BAGithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是高效的静态站点生成框架，她基于 Node.js。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。 搭建博客创建Github仓库在Github页面的右上方选择New repository进行仓库的创建 1my-name.github.io 安装配置Hexo 下载安装Hexo 1npm install -g hexo-cli 初始化Blog 1hexo init blog 下载dependencies 12cd blognpm install 站点配置(blog/_config.yml) 12345678910title: my-titlesubtitle: my-subtitledescription: my-descriptionauthor: my-namelanguage: zh-CNtimezone: Asia/Shanghaideploy: type: git repo: https://github.com/my-name/my-name.github.io.git branch: master 添加标签页面 1hexo new page "tags" 编辑页面(blog/source/tags) 12type: "tags"comments: false 添加评论系统 1234disqus: enable: true shortname: my-shortname count: true 添加NexT主题下载主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题(blog/_config.yml) 1theme: next 选择Scheme(blog/themes/next/_config.yml) 123#scheme: Musescheme: Mist#scheme: Pisces 设置头像(blog/themes/next/_config.yml) avatar放置在blog/themes/next/source/images/目录下 1avatar: /images/avatar.jpg 设置昵称 1author: my-name 站点描述 1description: 总有刁民想害朕 本地测试本地发布 1hexo server 浏览器访问http://localhost:4000/ 远程测试部署到Github 生成网站静态文件到默认public文件 1hexo generate 自动生成静态文件并部署到设定的仓库 1hexo deploy 浏览器访问http://my-name.github.io 如:http://hihcys.github.io 发表文章新建文章 1hexo new "my-first-article" 编辑文章(blog/source/_posts) 1retext my-first-article.md 提交到远程 12hexo generatehexo deploy 相关链接Hexo框架官方文档 Text主题官方文档 Git中文版学习资料]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
