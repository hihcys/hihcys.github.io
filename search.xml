<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[世界科学成长史]]></title>
    <url>%2F2020%2F06%2F18%2F%E4%B8%96%E7%95%8C%E7%A7%91%E5%AD%A6%E6%88%90%E9%95%BF%E5%8F%B2%2F</url>
    <content type="text"></content>
      <tags>
        <tag>科学</tag>
        <tag>中国</tag>
        <tag>外国</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春秋战国]]></title>
    <url>%2F2020%2F06%2F18%2F%E6%98%A5%E7%A7%8B%E6%88%98%E5%9B%BD%2F</url>
    <content type="text"><![CDATA[周天子的势力减弱，群雄纷争，齐桓公、宋襄公、晋文公、秦穆公、楚庄王相继称霸，史称“春秋五霸”。据史书记载，春秋二百四十二年间，有三十六名君主被臣下或敌国杀之，五十二个诸侯国被灭。有大小战事四百八十多次，诸侯的朝聘和盟会四百五十余次。战国承春秋时代的乱世，启帝秦发端，中续百家争鸣，各国相继图强而举国变法，涌现了大量名将争锋和名士纵横捭阖之典故，为后世传诵。 春秋时期周平王元年（前770年）到周敬王四十四年（前476年）为止。 重要事件周平王迁都周幽王时期，周室走向瓦解崩溃，废立太子宜臼，将西周推入深渊。宜臼外公申侯联合曾侯、许文公及犬戎（外族）推翻周幽王，都城宗周被毁坏，后周平王上任，前770年周平王被迫将国都从镐京迁至成周（雒邑）。因雒邑在镐京之东，此后的周朝史称东周。王室放弃了原本的关中地区（宗周），只有洛邑周边（成周）一小块王畿，而失去对其他诸侯国的控制。 卿士郑庄公周桓王十三年（前707年），由于郑庄公不尊王室的问题与郑国争执，周桓王率陈、蔡、卫等国军队讨伐郑国，郑庄公领兵抗拒，两军战于𦈡葛（今河南长葛北），史称“𦈡葛之战”，郑庄公打败了王师，一箭射中周王的肩膀。说明周王的地位已严重下降，只是还保存着天下共主的虚名罢了，诸侯争霸的时代正式到来。 齐桓公称霸前685年，齐国君主齐桓公继位，以管仲为相，实施变法，废除井田制度，按土地的肥瘠，确定赋税，设盐、铁官和铸钱，增加财政收入，寓兵于农，将基层行政组织和军事组织合为一体，增加了兵源和作战能力，迅速成为华夏各国中最富强的国家。然后就打起了“尊王攘夷”的口号，多次大会诸侯，帮助或干涉其他国家，抗击夷狄。 周惠王二十一年（前656年），齐桓公带领八个诸侯国的联军，陈兵“蛮夷”楚国边境，质询楚国为何不向周王室朝贡，迫使楚国签订召陵之盟，又于公元前651年举行葵丘会盟，成为春秋五霸之首。自此，齐桓公建立了会盟霸主的制度。 宋楚之争齐桓公死后，五公子夺位，齐国内乱不止。传说，齐桓公的五个儿子互相战争，箭矢射到了齐桓公的尸体上，都没有人顾及。南方的楚国兴起，自称为王，消灭了其北方的几个小国之后将矛头指向中原。宋襄公试图效法齐桓公，以抵抗楚国进攻为名，再次大会诸侯以成为霸主，但宋国实力与威望都不足。宋襄公十五年（前638年），宋楚两军交战于泓水。楚军渡河时宋大司马子鱼建议宋襄公“半渡击之”，宋襄公称趁敌渡河时攻击是为不仁不义拒绝建议；楚军渡河后子鱼建议趁楚军列阵混乱之时攻击，宋襄公再次以不仁不义为由拒绝。楚军列阵完毕后发起攻击，宋军大败，宋襄公大腿中箭，次年因伤重而死。楚成王称雄一时。 晋文公践土之盟在北方的晋国，与周室同宗。晋献公时期晋国向四面扩张，领土和国力大增。但献公宠信爱姬，废嫡立幼，致使国政大乱。前636年，晋献公之子重耳在秦穆公派出的军队护送下继承晋国君位，是为晋文公。他改革政治，发展经济，整军经武，取信于民，安定王室，友好秦国（秦晋之好），在诸侯中威信很高。周襄王二十年（前633年），楚军包围宋国都城商丘。次年初，晋文公率兵救宋，在城濮之战大败楚军，然后会盟于践土，成为中原霸主。 秦穆公独霸西戎晋文公死后，秦晋联盟被瓦解，秦穆公谋求向东方发展，被晋所阻。秦晋殽之战（前627年），秦全军覆没，大将孟明视被俘虏，隔年在彭衙之战再败，虽然以后有王官之战的胜利，但终没法挑战晋在中原的地位，惟有转而向西发展,秦穆公任用由余,吞并了一些戎狄部族，宽地千里，独霸西戎。 楚庄王问鼎中原楚国在城濮战后，向东发展，灭了许多小国，势力南到今云南，北达黄河。楚庄王改革内政，平息暴乱，启用贤臣孙叔敖兴修水利，改革军制，国力更为强大，在攻克陆浑戎后，竟陈兵周郊，向周定王的使者询问象征国家政权的传国宝器 - 九鼎的大小轻重，意在灭周自立，此即“问鼎”一词的来源。周定王十年（前597年），楚与晋会战于邲（邲之战），大胜晋国。前594年，楚围宋，宋告急于晋，晋不能救，宋遂与楚言和，尊楚。这时中原各国除晋、齐、鲁之外，尽尊楚庄王为霸主。 晋楚大战与弭兵会盟晋楚两大国之间连续不断的战争给人民带来巨大的灾难，也引起中小国家的厌倦，加以晋楚两大国势均力敌，谁都无法击垮对方。于是由宋国发起，于周简王七年（前579年）举行第一次“弭兵”会盟，是为华元弭兵。但是不久之后，会盟破裂。晋楚两国再度爆发两次大规模战役（前576年的鄢陵之战、前557年的湛阪之战），虽皆以晋国获胜收场，但楚国在中原地区仍与晋国保持势均力敌的态势，很多中原小国都备受到影响，疲惫不堪。周灵王二十六年（前546年），出于地缘政治的影响，宋国再次出面斡旋，邀请晋楚和各诸侯国举行第二次“弭兵”会盟，此后战争大大减少。史称‘向戌弭兵’。 吴越雄霸东南当中原诸侯争霸接近尾声时，地处江浙的吴、越开始发展。吴王阖闾重用孙武、伍子胥等人。周敬王十四年（前506年），吴王以伍子胥为大将，统兵伐楚。吴军攻进楚都郢，伍子胥为父兄报仇，掘楚平王墓，鞭尸三百。周敬王二十四年（前496年）吴军挥师南进伐越。越王勾践率兵迎战，越大夫灵姑浮一戈击中阖闾，阖闾因伤逝世。周敬王二十六年（前494年），吴王夫差为父报仇，兴兵败越。勾践求和，贿赂吴臣伯嚭并送给吴王珍宝和美女西施，自己亲自为夫差牵马。吴王拒绝了伍子胥联齐灭越的建议，接受越国求和，转兵向北进击，大败齐军，成为小霸。勾践卧薪尝胆，十年生聚，十年教训，终于在周元王三年（前473年）消灭吴国，夫差羞愤自杀。勾践北上与齐晋会盟于徐，成为最后一个霸主。 三家分晋在晋文公回晋即位的时候，有不少随从随他回国，结果这些人渐渐在晋国成为世袭贵族，而晋国的国政亦落入这些贵族（士大夫）的手上。前455年，晋国贵族只余下智、赵、韩、魏四家。智氏出兵攻赵氏，并胁迫魏韩两氏出兵。战事持续两年后，赵氏游说魏韩两家倒戈，灭智氏，瓜分智地并把持晋国国政，史称三家分晋。到晋幽公仅余绛、曲沃两地。前403年周威烈王册立韩赵魏三家为侯国，即为资治通鉴中春秋战国的分界点。 战国时期周敬王四十四年（前476）到秦始皇二十六年（前221年）秦统一中原。 重要事件李悝变法桓谭以为李悝为文侯师，班固、高诱以为是文侯之相。由于先秦文献缺乏记载，故此说尚难证实。但可以肯定的是李悝能参与机密，为文侯心腹之臣。司马迁说：“魏用李克尽地力，为强君。”班固称李悝“富国强兵”。 魏灭中山魏灭中山之战发生于战国时代初期(前408年至前406年)期间，魏国攻灭中山国的一场战争。周威烈王十八年至二十年(公元前408—前406年)，魏军在顾(今河北定州)攻灭中山国的作战。经过三年作战，中山军力量消耗已尽。二十年，魏军终于攻克顾城，占领中山国全境。魏文侯随即命太子击镇守中山地，而封乐羊于灵寿(今河北灵寿西北)。中山国亡。 三晋伐齐之战三晋伐齐之战是中国战国时代初期的一场大规模战争。前後耗时2年，以三晋胜利而告终。是役齐康公被联军所俘虏，与三晋之君一起朝见周天子。齐康公并请求封三晋为诸侯。次年，九鼎声响，三晋成为了诸侯。 吴起变法春秋中期后，晋国以“尽灭群公子”、“灭公族”等手段打击国君近亲势力、加强国君权力时，楚国才开始任用公子执政。公子执政初期，确实起到了强化王权的作用。但这实际是种落后任人唯亲的制度，其结果形成了王权旁落、大臣太重、封君太重的弊病。战国初期，楚国民不聊生，饿殍遍野，楚声王竟至为“盗”所杀。而此时北方三晋正在兴起，国力强大，对楚步步进逼，楚国处于十分困窘的境地。在楚国内忧外困之时，中原政治家吴起从魏国到楚国。楚悼王素闻吴起贤能，公元前382年，楚悼王任命吴起为令尹，主持变法。吴起变法，从打击大贵族入手。 阴晋之战阴晋之战是指公元前389年，秦军为夺取被魏占领的河西地区，而动用50万大军攻魏，而魏军在名将吴起率领下以在阴晋以少胜多的著名战役。 韩灭郑前423年，韩武子伐郑，杀郑幽公。郑人立幽公弟郑??公。前408年，韩景侯伐郑，取雍丘。郑在京筑城。前407年，郑伐韩，于负黍(在洛州阳城县西南三十五里)大败韩兵。前400年，郑围韩国阳翟。前398年，郑??公杀其相驷子阳。前396年，驷子阳之党杀弑??公而立幽公弟为郑康公。前394年，负黍反郑归韩。前385年，韩伐郑，取阳城。前375年，韩哀侯灭郑，不久迁都到郑国故都新郑。 浊泽之战周烈王七年(公元前369年)，在魏与韩赵之战中，韩、赵联军在浊泽(今山西运城境)进攻魏军的作战。 史称“浊泽之战”此战，联军在取得绝对优势的情况下，由于赵、韩的严重分歧，因不能协同而由胜转败，使魏国终免于分割。 商鞅变法商鞅变法是指战国时期秦国的秦孝公即位以后，决心图强改革，便下令招贤。商鞅自魏国入秦，并提出了废井田、重农桑、奖军功、实行统一度量和建立县制等一整套变法求新的发展策略，深得秦孝公的信任，任他为左庶长，开始变法。经过商鞅变法，秦国的经济得到发展，军队战斗力不断加强，发展成为战国后期最富强的封建国家。 桂陵之战桂陵之战是历史上一次著名截击战，发生在河南长垣西北的。周显王十五年(公元前354年)，魏围攻赵都邯郸，次年赵向齐求救。齐王命田忌、孙膑率军援救。孙膑认为魏以精锐攻赵，国内空虚，遂引兵攻魏都大梁(今河南开封)。果然诱使魏将庞涓赶回应战。孙膑又在桂陵(今河南长垣)伏袭，大败魏军，并生擒庞涓。孙膑在此战中避实击虚、攻其必救，创造了“围魏救赵”战法，成为两千多年来军事上诱敌就范的常用手段。 马陵之战公元前344年召集天下诸侯自立为王。齐、楚等大国不来还情有可原，但一向是魏国小弟的韩国没参加就让魏惠王生气了。于是魏国发兵攻韩，韩国向齐国求援，齐国再次以田忌、孙膑为将率军救韩，庞涓率魏军追击齐军，在马陵到遭埋伏，魏太子申被俘，魏军全军覆没，庞涓自刎而死。魏国在兵力缺乏、国力大衰的情况下，无暇对付秦军。 第五次河西之战公元前339年，秦军再由庞城渡河进攻，于岸门（今山西省河津县南）击败魏援军，俘主将魏错。次年年底，秦孝公死，秦惠文王继位，杀商鞅，重用魏人公孙衍。公元前332年，秦惠王派军攻魏上郡重地雕阴（今陕西甘泉南）。魏防守河西的主将龙贾，集中兵力迎战。经2年激战，至三十九年（公元前330年），全歼魏军，斩首4.5万（此据《史记.魏世家》，《秦本纪》为8万），并俘虏了龙贾。魏被迫于次年将河西郡归还秦国。至此，秦全部收复了被魏夺占的河西地区。 秦灭巴蜀周慎靓王五年(公元前316年)，秦国张仪、司马错等率军攻灭巴(今四川东部)、蜀(今四川西部)的作战。 齐破燕齐破燕之战，指前314年，齐国大举兴兵讨伐燕国，一度灭亡燕国的事件。前316年，燕王哙禅位于相国子之，进行改革，国内大乱。前314年，太子平与将军市被反叛，最后被平定，太子平、市被被杀，死者数万。此时，齐宣王派匡章率军，五十天内攻下燕国，燕王哙被杀，子之逃亡，后被齐人抓住做成肉酱。但是，齐军军纪败坏，燕国各地反抗。赵、魏、韩、楚、秦等国也反对齐国吞并燕国。前312年，齐国撤军。 楚灭越前306年，宜阳战后，秦武王死，秦国发生内乱。楚威王乘秦国无暇对楚用兵之际，利用越国内部不稳定的机会，派大臣昭滑率军攻越。楚军首先攻占原吴国统治的地区，尔后，继续向越进攻，占领越国全部领土，杀越王无疆，灭越，改越地为江东郡。越余部分为许多小国散处于滨海地区，朝服于楚。 伊阙之战周赧王二十二年(前293年)，秦国战神白起率秦军在洛阳龙门伊阙大破魏国、韩国联军，歼敌24万，夺取魏城数座及韩国安邑以东大部分地区。魏、韩两国割地求和。 齐灭宋齐灭宋之战发生於前286年，战国时代齐国攻灭宋国的一场战争。 燕破齐赵国赵武灵王派兵护送在韩国的燕国公子职回到燕国，即燕昭王。燕昭王不忘齐国灭国之仇，在前284年，派乐毅大举进攻齐国，攻入临淄，也使齐国濒临灭亡达五年(前284年—前279年)——燕攻齐之战。 鄢郢之战鄢郢之战是指公元前279—前278年，秦国名将白起率军深入楚国腹地攻下楚国鄢(今湖北宜城东南)、郢(今湖北江陵西北)的大规模作战，此次作战的胜利使得秦国获得了楚国大量国土，同时也对楚国予以了严重打击。 华阳之战华阳之战周赧王四十二年(公元前273年)，秦将白起于华阳(今河南新郑北)各个击破赵、魏联军的一次长途奔袭作战。 阏与之战周赧王四十六年(公元前269年)，赵国名将赵奢率军于阏与(今山西和顺西)，击败秦军的一次奔袭作战。 陉城之战公元前264年(周赧王五十一年)，秦武安君白起率军攻占韩国陉城(今山西曲沃东北)等9座城邑的作战。 长平之战公元前262年，前后耗时三年(近年来有一说为前期僵持对峙二年六个月，后期白热战六个月)。是我国历史上最早、规模最大的包围歼灭战。此场战争，发生于最有实力统一中国的秦赵两国，极大地加速了秦国统一中国的进程。 据载秦军前后坑杀赵军四十万人，被后人认为是战国形势的转折点。 此战后，山东诸侯国均不再有对抗秦军的实力。 五国攻秦之战五国攻秦之战是前241年赵、楚、魏、韩、燕五国联合进攻秦国的战争前241年，赵、楚、魏、韩、燕五国共推楚考烈王为纵约长，庞暖为联军主帅，共同攻打秦国。联军攻至函谷关时，秦军出击，诸侯联军败退。联军转而进攻秦国的盟国齐国，夺取了饶安(今河北省盐山县西南)。 秦灭六国之战秦灭六国之战，既是战国末期最后一场诸侯兼并战争，又是中国历史上最早的一场封建统一战争。战国末年，在七雄中日益强大的秦国在秦王嬴政的领导下，从公元前230年到公元前221年，秦国用了10年的时间，相继灭掉了北方的燕、赵，中原的韩、魏，东方的齐和南方的楚六个国家，结束了春秋以来长达500余年的诸侯割据纷争的战乱局面，并建立起中国有史以来第一个大一统的君主制王朝——秦朝。秦王政改号称皇帝，即赫赫大名的秦始皇，中国历史从此翻开了崭新的一页。]]></content>
      <tags>
        <tag>历史</tag>
        <tag>春秋</tag>
        <tag>战国</tag>
        <tag>周朝</tag>
        <tag>秦朝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一致性hash环及优化方法]]></title>
    <url>%2F2020%2F03%2F17%2F%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%8E%AF%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一致性哈希算法在1997年由麻省理工学院的Karger等人在解决分布式Cache中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得DHT可以在P2P环境中真正得到应用。 一致性hash的原理现在一致性hash算法在分布式系统中也得到了广泛应用，研究过memcached缓存数据库的人都知道，memcached服务器端本身不提供分布式cache的一致性，而是由客户端来提供，具体在计算一致性hash时采用如下步骤： 首先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上。 从上图的状态中添加一台memcached服务器。余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但Consistent Hashing中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响，如下图所示： 值得注意的是，一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。 优化方法通过增加虚拟节点来解决数据倾斜问题一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点： 当我们添加的虚拟节点越多，虚拟节点分布就越平均，数据倾斜的程度就越小。我们一般建议虚拟节点大概在200个左右。但是问题来了，如果大量的虚拟节点，节点的查找性能就成为必须考虑的因数。 使用红黑树来加快查找速度红黑树已经广泛应用，其原理就不再叙述了。 实现一致性哈希go语言版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358package hashring// 提供一个一致性哈希环功能// 加入了两个优化点// 1. 增加虚拟节点，用于删除节点后，可以把负载相对均匀地分布分布给其他节点// 2. 增加红黑树结构，优化查询节点的效率//// @author jintangimport ( "fmt" "strconv" "strings" "sync" "hash/crc32" "io" "github.com/HuKeping/rbtree")// Node 节点结构type Node struct &#123; ID string Host string Data *sync.Map&#125;// nodeKey 生成node keyfunc (n *Node) nodeKey() string &#123; return n.ID + "#" + n.Host&#125;// Less 实现rbtree接口方法Less// 实现改接口，可以使Node可以存入rbtree节点func (n *Node) Less(than rbtree.Item) bool &#123; return CalcCRC32([]byte(n.ID)) &lt; CalcCRC32([]byte(than.(*Node).ID))&#125;// VNode 虚拟节点type VNode struct &#123; Index uint32 // 索引值, 通过计算hashKey转crc32得来 NodeID string // Node节点ID&#125;// Less 实现rbtree接口方法Less// 实现改接口，可以使Node可以存入rbtree节点func (vn *VNode) Less(than rbtree.Item) bool &#123; return vn.Index &lt; than.(*VNode).Index&#125;// HashRing 哈希环type HashRing struct &#123; VRing *rbtree.Rbtree NRing *rbtree.Rbtree Nodes *sync.Map // map(NodeID =&gt; *Node) NodeStatus map[string]bool // map(NodeID =&gt; status) NodeCount uint32 NodeOkCount uint32 NumberOfVirtual uint32 sync.Mutex&#125;// virtualKey 生成虚拟节点的keyfunc (r *HashRing) virtualKey(nodeID string, index uint32) string &#123; return "node#" + nodeID + "#" + strconv.FormatUint(uint64(index), 10)&#125;// hashKey 获取哈希func (r *HashRing) hashKey(key string) string &#123; return CalcHash([]byte(key))&#125;// hashTOCRC32 hash转换RCR32func (r *HashRing) hashToCRC32(hashInString string) uint32 &#123; return CalcCRC32([]byte(hashInString))&#125;// CalcIndex 计算key的索引值func (r *HashRing) CalcIndex(key string) uint32 &#123; return r.hashToCRC32(r.hashKey(key))&#125;// AddNode 添加节点func (r *HashRing) AddNode(node *Node) &#123; r.Lock() defer r.Unlock() var numberOfNode uint32 = 1 if r.NumberOfVirtual &gt; 0 &#123; numberOfNode = r.NumberOfVirtual &#125; var i uint32 for i = 0; i &lt; numberOfNode; i++ &#123; index := r.hashToCRC32(r.hashKey(r.virtualKey(node.ID, i))) r.VRing.Insert(&amp;VNode&#123;Index: index, NodeID: node.ID&#125;) &#125; r.Nodes.Store(node.ID, node) r.NodeStatus[node.ID] = false r.NRing.Insert(node) r.NodeCount++&#125;// RemoveNode 删除节点func (r *HashRing) RemoveNode(nodeID string) bool &#123; r.Lock() defer r.Unlock() if val, ok := r.Nodes.Load(nodeID); ok &#123; node := val.(*Node) var numberOfNode uint32 = 1 if r.NumberOfVirtual &gt; 0 &#123; numberOfNode = r.NumberOfVirtual &#125; var i uint32 for i = 0; i &lt; numberOfNode; i++ &#123; index := r.hashToCRC32(r.hashKey(r.virtualKey(node.ID, i))) r.VRing.Delete(&amp;VNode&#123;Index: index, NodeID: node.ID&#125;) &#125; r.Nodes.Delete(node.ID) delete(r.NodeStatus, node.ID) r.NRing.Delete(node) r.NodeCount-- &#125; return true&#125;func (r *HashRing) Node(ID string) *Node &#123; if node, ok := r.Nodes.Load(ID); ok &#123; return node.(*Node) &#125; return nil&#125;func (r *HashRing) IsOnline(ID string) bool &#123; ok, online := r.NodeStatus[ID] return ok &amp;&amp; online&#125;func (r *HashRing) SetOffline(ID string) &#123; r.Lock() defer r.Unlock() if b, ok := r.NodeStatus[ID]; ok &amp;&amp; b &#123; r.NodeStatus[ID] = false r.NodeOkCount-- &#125;&#125;func (r *HashRing) SetOnline(ID string) &#123; r.Lock() defer r.Unlock() if b, ok := r.NodeStatus[ID]; ok &amp;&amp; !b &#123; r.NodeOkCount++ r.NodeStatus[ID] = true &#125;&#125;func (r *HashRing) RandomGetNodes(num int) []*Node &#123; if r.NodeOkCount &lt;= 0 &#123; return nil &#125; if r.NodeOkCount &lt; uint32(num) &#123; num = int(r.NodeOkCount) &#125; nodes := make([]*Node, num) ids := make([]string, 0) for id, ok := range r.NodeStatus &#123; if ok &#123; ids = append(ids, id) &#125; &#125; indexes := utils.GenerateRandomNumber(0, len(ids), num) for i, idx := range indexes &#123; if node, ok := r.Nodes.Load(ids[idx]); ok &#123; nodes[i] = node.(*Node) &#125; &#125; return nodes&#125;// GetNode 定位节点// @params key 直接通过key值获取func (r *HashRing) GetNode(key string) (uint32, string) &#123; keyIndex := r.hashToCRC32(r.hashKey(key)) return r.GetNodeByIndex(keyIndex)&#125;// GetNodeMissNodeID 获取节点，排除不要的的节点// @params key 直接通过key获取，NodeID需要排除的节点IDfunc (r *HashRing) GetNodeMissNodeIDs(key string, NodeIDs []string) (uint32, string) &#123; if len(NodeIDs) &lt;= 0 &#123; return r.GetNode(key) &#125; if uint32(len(NodeIDs)) &gt;= r.NodeCount || r.NodeCount &lt;= 0 &#123; return 0, "" &#125; for _, id := range NodeIDs &#123; r.SetOffline(id) &#125; index, id := r.GetNode(key) for _, id := range NodeIDs &#123; r.SetOffline(id) &#125; return index, id&#125;// GetNodeUpDownNodes 获取节点上下游节点// @params NodeID节点IDfunc (r *HashRing) GetNodeUpDownNodes(NodeID string) (string, string) &#123; if NodeID == "" || !r.NodeStatus[NodeID] || r.NodeCount &lt;= 0 &#123; return "", "" &#125; if r.NRing.Len() &gt; 1 &#123; up := r.NRing.Max().(*Node).ID down := r.NRing.Min().(*Node).ID r.NRing.Descend(&amp;Node&#123;ID: NodeID&#125;, func(item rbtree.Item) bool &#123; if CalcCRC32([]byte(NodeID)) == CalcCRC32([]byte(item.(*Node).ID)) &#123; return true &#125; up = item.(*Node).ID return false &#125;) r.NRing.Ascend(&amp;Node&#123;ID: NodeID&#125;, func(item rbtree.Item) bool &#123; if CalcCRC32([]byte(NodeID)) == CalcCRC32([]byte(item.(*Node).ID)) &#123; return true &#125; down = item.(*Node).ID return false &#125;) return up, down &#125; return "", ""&#125;// GetNodeByIndex 定位节点// @params keyIndex 通过索引值获取func (r *HashRing) GetNodeByIndex(keyIndex uint32) (uint32, string) &#123; if r.VRing.Len() &gt; 0 &#123; minVNodeOfRing := r.VRing.Min().(*VNode) vNode := minVNodeOfRing r.VRing.Ascend(&amp;VNode&#123;Index: keyIndex&#125;, func(item rbtree.Item) bool &#123; vNode = item.(*VNode) if r.NodeStatus[vNode.NodeID] == false &#123; return true &#125; return false &#125;) if !r.NodeStatus[vNode.NodeID] &#123; r.VRing.Ascend(minVNodeOfRing, func(item rbtree.Item) bool &#123; vNode = item.(*VNode) if r.NodeStatus[vNode.NodeID] == false &#123; return true &#125; return false &#125;) &#125; return vNode.Index, vNode.NodeID &#125; return 0, ""&#125;// PrintNodes 打印所有真实节点func (r *HashRing) PrintNodes() &#123; if r.NodeCount &lt;= 0 &#123; fmt.Println("nodes is empty") return &#125; r.Nodes.Range(func(key, value interface&#123;&#125;) bool &#123; node := value.(*Node) fmt.Println(strings.Repeat("=", 30)) fmt.Println("NodeID:", node.ID) fmt.Println("NodeHost:", node.Host) fmt.Println("NodeKey :", node.nodeKey()) fmt.Println() return true &#125;)&#125;// TraversalVRing 遍历虚拟节点二叉树func (r *HashRing) TraversalVRing() &#123; r.VRing.Ascend(r.VRing.Min(), func(item rbtree.Item) bool &#123; fmt.Printf("vNode %d =&gt; %s\n", item.(*VNode).Index, item.(*VNode).NodeID) return true &#125;)&#125;// TraversalNRing 遍历真实节点二叉树func (r *HashRing) TraversalNRing() &#123; r.NRing.Ascend(r.NRing.Min(), func(item rbtree.Item) bool &#123; fmt.Printf("Node %d =&gt; %s\n", CalcCRC32([]byte(item.(*Node).ID)), item.(*Node).ID) return true &#125;)&#125;// NewHashRing 新建一个hash环func New(numOfVNode uint32) *HashRing &#123; r := new(HashRing) r.Nodes = new(sync.Map) r.NodeStatus = make(map[string]bool) r.NodeCount = 0 r.NumberOfVirtual = numOfVNode r.VRing = rbtree.New() r.NRing = rbtree.New() return r&#125;// CalcCRC32 计算crc32func CalcCRC32(data []byte) uint32 &#123; iEEE := crc32.NewIEEE() io.WriteString(iEEE, string(data)) return iEEE.Sum32()&#125;]]></content>
      <tags>
        <tag>golang</tag>
        <tag>hash</tag>
        <tag>一致性hash</tag>
        <tag>p2p</tag>
        <tag>分布式系统</tag>
        <tag>虚拟节点</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka基本原理]]></title>
    <url>%2F2019%2F12%2F30%2Fkafka%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Kafka 是一个基于分布式的消息发布-订阅系统，它被设计成快速、可扩展的、持久的。与其他消息发布-订阅系统类似，Kafka 在主题当中保存消息的信息。生产者向主题写入数据，消费者从主题读取数据。由于 Kafka 的特性是支持分布式，同时也是基于分布式的，所以主题也是可以在多个节点上被分区和覆盖的。 专业术语Broker：Kafka 集群包含一个或多个服务器，这种服务器被称为 broker。 Topic：每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。 Partition：Partition 是物理上的概念，每个 Topic 包含一个或多个 Partition。 Producer：负责发布消息到 Kafka broker。 Consumer：消息消费者，向 Kafka broker 读取消息的客户端。 Consumer Group：每个 Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。]]></content>
      <tags>
        <tag>kafka</tag>
        <tag>apache</tag>
        <tag>消息系统</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制——Git的使用]]></title>
    <url>%2F2019%2F11%2F05%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94Git%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <tags>
        <tag>版本控制</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非对称加密的原理及应用]]></title>
    <url>%2F2019%2F10%2F29%2F%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引用来自wiki对于非对称加密的通俗介绍：在现实世界上可作比拟的例子是，一个传统保管箱，开门和关门都是使用同一条钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有信箱主人拥有钥匙可以打开信箱，这就视为私钥，这是非对称加密。RSA是使用最为广泛的非对称加密算法，而http到https的演进就依赖于RSA非对称加密算法。 HTTP到HTTPS的演进HTTPHTTP协议是基于传输层TCP协议的应用层协议，时至今日，它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP是一个client-server协议：请求通过一个实体被发出，实体也就是用户代理。大多数情况下，这个用户代理都是指浏览器，当然它也可能是任何东西，比如一个爬取网页生成维护搜索引擎索引的机器爬虫。每一个发送到服务器的请求，都会被服务器处理并返回一个消息，也就是response。HTTP是简单的、可扩展的、无状态的、有会话的、面向连接的传输协议。但是HTTP也存在以下问题： 通讯使用明文，可能被窃听。 无法证明报文的完整性，可能被篡改。 无法验证通讯方的身份，可能被欺骗。 HTTPSHTTPS使用TLS/SSL作为传输层安全协议，拥有认证、保密和数据完整性功能。HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 TLS/SSL = 非对称加密(RSA) + 对称加密(AES) + 散列算法(SHA)。 解决内容可能被窃听的问题——非对称加密+对称加密。 解决报文可能遭篡改问题——数字签名。 解决通信方身份可能被伪装的问题——数字证书。 1.Client发起一个HTTPS（比如https://juejin.im/user/5a9a9cdcf265da238b7d771c）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。 2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。 3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。 4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。6.Server使用对称密钥加密“明文内容A”，发送给Client。 7.Client使用对称密钥解密响应的密文，得到“明文内容A”。 8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。 RSA加密算法为什么要使用公钥加密私钥解密？ 密码学的假设是：一个合格的加密方案，敌手拿到明文c不能恢复明文m。如果颠倒过来，所有人都可以解密，那毫无意义。 为了满足密码标准，非对称加密的加密密钥尽可能更安全高效，而私钥尽可能保证安全，防止被破解，这就导致人们设计时公钥加解密比私钥加解密快。所以要用公钥进行加密，私钥进行解密。test1]]></content>
      <tags>
        <tag>密钥</tag>
        <tag>非对称加密</tag>
        <tag>对称加密</tag>
        <tag>http</tag>
        <tag>https</tag>
        <tag>RSA</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[食物寒凉温热属性速查]]></title>
    <url>%2F2019%2F09%2F17%2F%E9%A3%9F%E7%89%A9%E5%AF%92%E5%87%89%E6%B8%A9%E7%83%AD%E5%B1%9E%E6%80%A7%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[中医认为“寒凉为阴，温热为阳”，只有将食物的寒凉温热因人、因时、因地的灵活运用，才能使人体在任何时候都能做到阴阳平衡。其一，根据个人体质选择食物，身体内寒气较重、气血两亏的虚弱之人不分季节，要多吃温热性质的食物，使机能兴奋、增加活力，血脉畅通；如果身体内热量较大、精力旺盛，要适当地选用一些寒凉的食物来进行平衡。其二，气候的变化说到底就是温度的变化，温度高时人要多吃寒凉的食物清热，温度低时要以温热的食物保暖祛寒。其三，每个地区因气候、地理的不同都生长着不同的食物，最明显的就是炎热之地多盛产寒冷性质的水果，而寒冷地区多生长温热的食物，这是大自然给我们准备好的食物，是完全适合身体的东西，正所谓“一方水土养一方人”。 食物分类食物的四性是指寒、凉、温、热四种属性，寒热属性不明显的食物归于平性，但习惯仍称为四性。 寒 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 大白菜 胶菜、绍菜 寒 10月-3月 牛肉、豆腐 兔肉、动物肝脏 2 茄子 茄瓜、矮瓜 寒 6月-7月 猪肉、羊肉 蟹、墨鱼 3 蟹 寒 茄子、西红柿 4 墨鱼 寒 茄子 5 苦瓜 癞瓜、凉瓜 寒 3月-8月 鸡蛋、鹌鹑蛋 动物肝脏、豆腐 6 西葫芦 茭瓜、角瓜 寒 3月-8月 豆腐、鸡蛋、韭菜 7 莴笋 莴苣、青笋、生笋 寒 12月-2月 蒜薹、沙拉酱 蜂蜜、乳酪 8 竹笋 竹萌、竹芽 寒 3月-11月 鸡肉、猪肉、酸菜 红糖、山楂 9 芦笋 文山竹、笋尖马 寒 4月-5月 冬瓜、海参、猪肉、黄芪 10 莲藕 藕、河梗、灵根 寒 12月-5月 凉 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 兔肉 凉 大白菜 2 油菜 芸薹、胡菜、寒菜 凉 10月-12月 香菇、虾仁 胡萝卜、动物肝脏 3 白萝卜 菜菔、罗服 凉 11月-2月 鸡肉、羊肉 梨、柑橘 4 西红柿 番茄、洋茄子 凉 7月-9月 菜花、鸡蛋、圆白菜、芹菜 虾、蟹、黄瓜 5 冬瓜 白瓜、白冬瓜、枕瓜 凉 12月-5月 香菇、海带、芦笋 鲫鱼、红豆 6 黄瓜 胡瓜、刺瓜、王瓜 凉 5月-6月 豆腐、虾 西红柿、花生、菠菜 7 丝瓜 天罗、绵瓜、布瓜、天罗瓜 凉 6月-8月 8 菠菜 菠棱、赤根菜 凉 3月-11月 鸡蛋、猪血 豆腐、黄瓜 9 芹菜 胡芹、旱芹、水芹 凉 11月-3月 西红柿、牛肉 鸡肉 平 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 西兰花 绿花椰菜、绿花菜 平 5月 平菇、金针菇、豆浆、百合 2 菜花 花菜、花椰菜 平 5月 猪肉、鸡肉、鸡蛋 动物肝脏、胡萝卜 3 豇豆 饭豆、长豆角 平 6月-9月 猪肉 4 胡萝卜 黄萝卜、红萝卜 平 9月-2月 羊肉、猪肝 山楂、醋 5 圆白菜 包心菜、卷心菜 平 3月-8月 黑木耳、西红柿 动物肝脏 6 土豆 马铃薯、洋芋 平 12月-5月 牛肉、豆角 柿子、香蕉 7 茼蒿 蓬蒿、蒿子轩、皇帝菜 平 12月-5月 温 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 鲫鱼 温 冬瓜 2 南瓜 矮瓜、番瓜、麦瓜 温 7月-9月 芦荟、莲子 红薯、带鱼 3 青椒 柿子椒、甜椒 温 3月-8月 4 尖椒 温 3月-8月 5 洋葱 葱头、徐聪、圆葱 温 9月-2月 6 川七 温 7 山药 温 8 包心芹菜 温 9 明日叶 温 10 韭菜 温 11 韭菜花 温 12 紫苏 温 13 雪里红 雪菜、春不老、香青菜 温 14 袖珍菇 温 15 鲍鱼菇 温 16 黑豆芽 温 17 桃子 温 18 杨梅 温 19 水蜜桃 温 20 红枣 温 21 荔枝 温 22 龙眼 桂圆 温 23 樱桃 温 24 石榴 温 25 红毛丹 温 26 鸭梨 温 27 金桔 温 28 扁豆 藤豆、鹊豆、豆角 温 29 松子 温 30 栗子 温 31 核桃 温 32 雪莲子 温 33 高粱 温 34 西谷米 温 35 糯米 温 36 牛肉 温 37 羊肉 温 38 鸡肉 温 39 火腿 温 40 羊肚 温 41 羊肾 温 42 鸡心 温 43 猪肚 温 44 猪肝 温 45 鹅肝 温 46 羊奶 温 47 鸡蛋黄 温 48 白带鱼 温 49 草鱼 温 50 鳝鱼 温 51 鲫鱼 温 52 鲢鱼 温 53 海参 温 54 虾子 温 55 虾米 温 56 龙虾 温 57 沙拉油 温 58 红砂糖 温 59 麦芽糖 温 60 黑糖 温 61 醋 温 62 蒜 温 63 红花 温 64 香椿 温 65 丁香 温 66 月桂叶 温 67 左手香 温 68 百香里 温 69 茴香菜 温 70 玫瑰 温 71 茉莉 温 72 桂花 温 73 红茶 温 74 咖啡 温 75 米酒 温 热 序号 名称 别名 四性 食用时令 搭配适宜 搭配忌讳 1 榴莲 热 2 山葵 热 3 白胡椒 热 4 黑胡椒 热 5 朝天椒 热 6 肉桂 热 7 八角 热 8 葡萄酒 热 9 辣椒 热 参考资料食物寒凉温热属性功效速查手册 食物寒熱溫涼屬性表 备注内容持续更新中，敬请期待……]]></content>
      <tags>
        <tag>食物</tag>
        <tag>寒凉温热</tag>
        <tag>四性</tag>
        <tag>食用时令</tag>
        <tag>食物搭配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang深入学习——float]]></title>
    <url>%2F2019%2F09%2F07%2FGolang%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94float%2F</url>
    <content type="text"><![CDATA[在计算机科学中，浮点数是一种对于实数的近似值数值表现法，利用浮点进行运算，称为浮点计算，这种运算通常伴随着因为无法精确表示而进行的近似或舍入。Go提供了两种size的浮点数，float32和float64。它们的算术规范是由IEEE754国际标准定义，现代CPU都实现了这个规范。 内存中的float32定义float32——单精度浮点类型使用32位（4个字节）存储一个浮点数。 IEEE754-2008中定义了它的结构： 符号位 指数 尾数 S EEEEEEEE FFFFFFFFFFFFFFFFFFFFFFF 1位二进制表示符号: 0,正; 1,负 8位二进制表示127偏移量的指数 23位二进制表示23+1位小数部分 例子以6.9为例子，将生活中常见的十进制转化为机器存储的二进制float。 将整数和小数部分分别转化为二进制； 1236（十进制） = 110（二进制）0.9（十进制） = 1110011001100......（二进制）6.9（十进制） = 110.1110011001100......（二进制） 将小数点左移（或右移）到第一个有效数字之后； 1110.1110011001100...... =&gt; 1.101110011001100......（左移2位） 填充尾数部分； 1从小数点后第一位开始，数出23个来，填充到上面float内存结构的尾数部分。默认小数点前面一定有且只有一个1，所以把这个1省略了，这也是为什么定义中尾数是23+1位的原因。 填充指数部分； 1238位表示阶码，无符号是[1,254]，0和255用于表示非规格化情况，有符号位是[-126,127]，引入偏移量以免使用补码带来计算复杂度。这个指数就是刚才我们把小数点移动的位数，左移为正，右移为负，用来计算指数的偏移量为127，指数应该是2+127=129。129（十进制） = 10000001（十进制） 填充符号位。 符号位 指数 尾数 0 10000001 10111001100110011001100 不精确的原因 浮点型只有最后一位为5时才能用有限位数的二进制来表示； 单精度浮点型尾数部分只能保存23位。 内存中的float64float64——双精度浮点类型使用64位（8个字节）存储一个浮点数。 IEEE754-2008中定义了它的结构： 符号位 指数 尾数 S EEEEEEEEEEE FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 1位二进制表示符号: 0,正; 1,负 11位二进制表示1023偏移量的指数 52位二进制表示52+1位小数部分]]></content>
      <tags>
        <tag>golang</tag>
        <tag>float</tag>
        <tag>浮点数</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang深入学习——map]]></title>
    <url>%2F2019%2F09%2F05%2FGolang%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94map%2F</url>
    <content type="text"><![CDATA[在Go语言中，一个map就是一个哈希表的引用，哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。对于V对应的value数据类型则没有任何的限制。 基本操作创建内置的make函数： 1ages := make(map[string]int) map字面值的语法： 1234ages := map[string]int&#123; "alice": 31, "charlie": 34,&#125; 访问通过key对应的下标语法访问： 12ages["alice"] = 32fmt.Println(ages["alice"]) 即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值。 元素是否真的是在map之中： 1234age, ok := ages["bob"]if !ok &#123; //do something&#125; 删除使用内置的delete函数可以删除元素： 1delete(ages, "alice") 遍历想遍历map中全部的key/value对的话，可以使用range风格的for循环实现： 123for name, age := range ages &#123; fmt.Printf("%s\t%d\n", name, age)&#125; Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。 数据结构存储查询Golang采用的是哈希查找表，并且使用链表解决哈希冲突。 1234567891011121314151617181920// A header for a Go map.type hmap struct &#123; // 元素个数，调用 len(map) 时，直接返回此值 count int flags uint8 // buckets 的对数 log_2 B uint8 // overflow 的 bucket 近似数 noverflow uint16 // 计算 key 的哈希的时候会传入哈希函数 hash0 uint32 // 指向 buckets 数组，大小为 2^B // 如果元素个数为0，就为 nil buckets unsafe.Pointer // 扩容的时候，buckets 长度会是 oldbuckets 的两倍 oldbuckets unsafe.Pointer // 指示扩容进度，小于此地址的 buckets 迁移完成 nevacuate uintptr extra *mapextra // optional fields&#125; 说明一下，B 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。bucket 里面存储了 key 和 value。buckets 是一个指针，最终它指向的是一个结构体： 123type bmap struct &#123; tophash [bucketCnt]uint8&#125; bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。 每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 overflow 指针连接起来。 key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。 buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。 循环遍历map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key/value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。 当然，Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了。 多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。 再明确一个问题：如果扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶。 map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。 一般而言，这可以通过读写锁来解决：sync.RWMutex。 读之前调用 RLock() 函数，读完之后调用 RUnlock() 函数解锁；写之前调用 Lock() 函数，写完之后，调用 Unlock() 解锁。 另外，sync.Map 是线程安全的 map，也可以使用。]]></content>
      <tags>
        <tag>golang</tag>
        <tag>数据结构</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库安全——SQL注入]]></title>
    <url>%2F2017%2F04%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[不管用什么语言编写的Web应用，它们都用一个共同点，具有交互性并且多数是数据库驱动。在网络中，数据库驱动的Web应用随处可见，由此而存在的SQL注入是影响企业运营且最具破坏性的漏洞之一。 SQL注入定义SQL注入（SQL injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。 简单解释：SQL注入就是一种通过操作输入来修改后台SQL语句达到代码执行进行攻击目的的技术。 SQL注入实例多语句执行注入Get请求语句： 1http://localhost/test/userinfo.php?username=plhwin SQL语句： 1SELECT uid,username FROM user WHERE username='plhwin' 如果用户Get请求改为： 1http://localhost/test/userinfo.php?username=plhwin';SHOW TABLES-- hack SQL语句变为： 1SELECT uid,username FROM user WHERE username='plhwin';SHOW TABLES-- hack' 经过上面的SQL注入后，页面输出了所有表信息。 如果用户接着Get请求： 1http://localhost/test/userinfo.php?username=plhwin';DROP TABLE user-- hack 整个user数据库表都消失了。 or方法注入一Web登录表单： 12345&lt;form action="/login" method="POST"&gt; &lt;p&gt;Username: &lt;input type="text" name="username" /&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input type="password" name="password" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="登录" /&gt;&lt;/p&gt;&lt;/form&gt; 后台处理逻辑： 123username:=r.Form.Get("username")password:=r.Form.Get("password")sql:="SELECT * FROM user WHERE username='"+username+"' AND password='"+password+"'" 普通用户输入： 12账户：myuser密码：xxx SQL语句： 1SELECT * FROM user WHERE username='myuser' AND password='xxx' 如果用户输入： 12账户：myuser' or 'foo' = 'foo' --密码：xxx SQL语句变为： 1SELECT * FROM user WHERE username='myuser' or 'foo' = 'foo' --'' AND password='xxx' 在SQL里面–是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。 or方法注入二SQL语句： 1strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');" 如果用户输入： 12userName = "1' OR '1'='1";passWord = "1' OR '1'='1"; SQL语句变为： 1strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');" 上面的SQL语句相当于： strSQL = “SELECT * FROM users;” 控制系统某些版本MSSQL数据库系统命令： 12sql:="SELECT * FROM products WHERE name LIKE '%"+prod+"%'"Db.Exec(sql) 如果攻击者提交一下内容作为变量prod的值： 1a%' exec master..xp_cmdshell 'net user test testpass /ADD' -- SQL语句变为： 1SELECT * FROM products WHERE name LIKE '%a%' exec master..xp_cmdshell 'net user test testpass /ADD'--%' MSSQL服务器会执行这条SQL语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以sa运行而 MSSQLSERVER服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。 可能危害 数据表中的数据外泄，例如个人机密数据，账户数据，密码等。 数据结构被黑客探知，得以做进一步攻击（例如SELECT * FROM sys.tables）。 数据库服务器被攻击，系统管理员账户被窜改（例如ALTER LOGIN sa WITH PASSWORD=’xxxxxx’）。 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及XSS等。 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如xp_cmdshell “net stop iisadmin”可停止服务器的IIS服务）。 破坏硬盘数据，瘫痪全系统（例如xp_cmdshell “FORMAT C:”）。 避免办法SQL注入攻击的危害这么大，那么该如何来防治呢?下面这些建议或许对防治SQL注入有一定的帮助。 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害。 检查输入的数据是否具有所期望的数据格式，严格限制变量的类型，例如使用regexp包进行一些匹配处理，或者使用strconv包对字符串转化成其他基本类型的数据进行判断。 对进入数据库的特殊字符（’”\尖括号&amp;*;等）进行转义处理，或编码转换。Go的text/template包里面的HTMLEscapeString函数可以对字符串进行转义处理。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句。例如使用database/sql里面的查询函数Prepare和Query，或者Exec(query string, args …interface{})。 在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。 避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。]]></content>
      <tags>
        <tag>datebase</tag>
        <tag>safe</tag>
        <tag>sql</tag>
        <tag>injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装NexT主题搭建Github博客]]></title>
    <url>%2F2017%2F03%2F27%2FHexo%E5%AE%89%E8%A3%85NexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BAGithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是高效的静态站点生成框架，她基于 Node.js。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。 搭建博客创建Github仓库在Github页面的右上方选择New repository进行仓库的创建 1my-name.github.io 安装配置Hexo 下载安装Hexo 1npm install -g hexo-cli 初始化Blog 1hexo init blog 下载dependencies 12cd blognpm install 站点配置(blog/_config.yml) 12345678910title: my-titlesubtitle: my-subtitledescription: my-descriptionauthor: my-namelanguage: zh-CNtimezone: Asia/Shanghaideploy: type: git repo: https://github.com/my-name/my-name.github.io.git branch: master 添加标签页面 1hexo new page "tags" 编辑页面(blog/source/tags) 12type: "tags"comments: false 添加评论系统 1234disqus: enable: true shortname: my-shortname count: true 添加NexT主题下载主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题(blog/_config.yml) 1theme: next 选择Scheme(blog/themes/next/_config.yml) 123#scheme: Musescheme: Mist#scheme: Pisces 设置头像(blog/themes/next/_config.yml) avatar放置在blog/themes/next/source/images/目录下 1avatar: /images/avatar.jpg 设置昵称 1author: my-name 站点描述 1description: 总有刁民想害朕 本地测试本地发布 1hexo server 浏览器访问http://localhost:4000/ 远程测试部署到Github 生成网站静态文件到默认public文件 1hexo generate 自动生成静态文件并部署到设定的仓库 1hexo deploy 浏览器访问http://my-name.github.io 如:http://hihcys.github.io 发表文章新建文章 1hexo new "my-first-article" 编辑文章(blog/source/_posts) 1retext my-first-article.md 提交到远程 12hexo generatehexo deploy 相关链接Hexo框架官方文档 Text主题官方文档 Git中文版学习资料]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
